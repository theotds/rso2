//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.6
//
// <auto-generated>
//
// Generated from file `mpk.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __mpk_h__
#define __mpk_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/ExceptionHelpers.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 6
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace MPK
{

class Line;
class LinePrx;
class Tram;
class TramPrx;
class Stop;
class StopPrx;
class User;
class UserPrx;
class SIP;
class SIPPrx;

}

namespace MPK
{

using lines = ::std::vector<::std::shared_ptr<LinePrx>>;

using stops = ::std::vector<::std::shared_ptr<StopPrx>>;

using trams = ::std::vector<::std::shared_ptr<TramPrx>>;

class noSuchLine : public ::Ice::UserExceptionHelper<noSuchLine, ::Ice::UserException>
{
public:

    virtual ~noSuchLine();

    noSuchLine(const noSuchLine&) = default;

    noSuchLine() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

/// \cond INTERNAL
static noSuchLine _iceS_noSuchLine_init;
/// \endcond

class noSuchTram : public ::Ice::UserExceptionHelper<noSuchTram, ::Ice::UserException>
{
public:

    virtual ~noSuchTram();

    noSuchTram(const noSuchTram&) = default;

    noSuchTram() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

struct TimeOfDay
{
    short hour;
    short minute;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const short&, const short&> ice_tuple() const
    {
        return std::tie(hour, minute);
    }
};

struct ArrivalInfoItem
{
    ::std::shared_ptr<::MPK::TramPrx> tram;
    ::MPK::TimeOfDay time;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::MPK::TramPrx>&, const ::MPK::TimeOfDay&> ice_tuple() const
    {
        return std::tie(tram, time);
    }
};

using arrivals = ::std::vector<ArrivalInfoItem>;

class noSuchUser : public ::Ice::UserExceptionHelper<noSuchUser, ::Ice::UserException>
{
public:

    virtual ~noSuchUser();

    noSuchUser(const noSuchUser&) = default;

    noSuchUser() = default;

    /**
     * Obtains a tuple containing all of the exception's data members.
     * @return The data members in a tuple.
     */
    std::tuple<> ice_tuple() const
    {
        return std::tie();
    }

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();
};

struct ScheduleItem
{
    ::std::shared_ptr<::MPK::StopPrx> stop;
    ::MPK::TimeOfDay time;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::shared_ptr<::MPK::StopPrx>&, const ::MPK::TimeOfDay&> ice_tuple() const
    {
        return std::tie(stop, time);
    }
};

using schedule = ::std::vector<ScheduleItem>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace MPK
{

class SIP : public virtual ::Ice::Object
{
public:

    using ProxyType = SIPPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual lines getLines(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void addLine(::std::shared_ptr<LinePrx> line, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_addLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void removeLine(::std::shared_ptr<LinePrx> line, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_removeLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::shared_ptr<StopPrx> getStop(int ID, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getStop(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class Stop : public virtual ::Ice::Object
{
public:

    using ProxyType = StopPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual lines getLines(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual int getID(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getID(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string getName(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getName(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual arrivals getArrivals(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getArrivals(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void registerUser(::std::shared_ptr<UserPrx> user, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerUser(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unregisterUser(::std::shared_ptr<UserPrx> user, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_unregisterUser(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class Line : public virtual ::Ice::Object
{
public:

    using ProxyType = LinePrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual trams getTrams(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getTrams(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual stops getStops(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getStops(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void addTram(::std::shared_ptr<TramPrx> tram, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_addTram(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void removeTram(::std::shared_ptr<TramPrx> tram, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_removeTram(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class Tram : public virtual ::Ice::Object
{
public:

    using ProxyType = TramPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::std::shared_ptr<StopPrx> getStop(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getStop(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual TimeOfDay getStopTime(int stopid, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getStopTime(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual int getID(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getID(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual schedule getSchedule(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getSchedule(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void registerUser(::std::shared_ptr<UserPrx> user, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_registerUser(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unregisterUser(::std::shared_ptr<UserPrx> user, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_unregisterUser(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class User : public virtual ::Ice::Object
{
public:

    using ProxyType = UserPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void updateStop(::std::shared_ptr<TramPrx> tram, ::std::shared_ptr<StopPrx> stop, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_updateStop(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void updateSchedule(::std::shared_ptr<StopPrx> stop, arrivals arr, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_updateSchedule(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace MPK
{

class SIPPrx : public virtual ::Ice::Proxy<SIPPrx, ::Ice::ObjectPrx>
{
public:

    lines getLines(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::MPK::lines>(true, this, &SIPPrx::_iceI_getLines, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getLinesAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::MPK::lines>>().get_future())
    {
        return _makePromiseOutgoing<::MPK::lines, P>(false, this, &SIPPrx::_iceI_getLines, context);
    }

    ::std::function<void()>
    getLinesAsync(::std::function<void(::MPK::lines)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::MPK::lines>(std::move(response), std::move(ex), std::move(sent), this, &MPK::SIPPrx::_iceI_getLines, context);
    }

    /// \cond INTERNAL
    void _iceI_getLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MPK::lines>>&, const ::Ice::Context&);
    /// \endcond

    void addLine(const ::std::shared_ptr<LinePrx>& line, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &SIPPrx::_iceI_addLine, line, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto addLineAsync(const ::std::shared_ptr<LinePrx>& line, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &SIPPrx::_iceI_addLine, line, context);
    }

    ::std::function<void()>
    addLineAsync(const ::std::shared_ptr<LinePrx>& line,
                 ::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPK::SIPPrx::_iceI_addLine, line, context);
    }

    /// \cond INTERNAL
    void _iceI_addLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<LinePrx>&, const ::Ice::Context&);
    /// \endcond

    void removeLine(const ::std::shared_ptr<LinePrx>& line, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &SIPPrx::_iceI_removeLine, line, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto removeLineAsync(const ::std::shared_ptr<LinePrx>& line, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &SIPPrx::_iceI_removeLine, line, context);
    }

    ::std::function<void()>
    removeLineAsync(const ::std::shared_ptr<LinePrx>& line,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPK::SIPPrx::_iceI_removeLine, line, context);
    }

    /// \cond INTERNAL
    void _iceI_removeLine(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<LinePrx>&, const ::Ice::Context&);
    /// \endcond

    ::std::shared_ptr<StopPrx> getStop(int ID, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::MPK::StopPrx>>(true, this, &SIPPrx::_iceI_getStop, ID, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getStopAsync(int ID, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::MPK::StopPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::MPK::StopPrx>, P>(false, this, &SIPPrx::_iceI_getStop, ID, context);
    }

    ::std::function<void()>
    getStopAsync(int ID,
                 ::std::function<void(::std::shared_ptr<::MPK::StopPrx>)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::MPK::StopPrx>>(std::move(response), std::move(ex), std::move(sent), this, &MPK::SIPPrx::_iceI_getStop, ID, context);
    }

    /// \cond INTERNAL
    void _iceI_getStop(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::MPK::StopPrx>>>&, int, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    SIPPrx() = default;
    friend ::std::shared_ptr<SIPPrx> IceInternal::createProxy<SIPPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class StopPrx : public virtual ::Ice::Proxy<StopPrx, ::Ice::ObjectPrx>
{
public:

    lines getLines(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::MPK::lines>(true, this, &StopPrx::_iceI_getLines, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getLinesAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::MPK::lines>>().get_future())
    {
        return _makePromiseOutgoing<::MPK::lines, P>(false, this, &StopPrx::_iceI_getLines, context);
    }

    ::std::function<void()>
    getLinesAsync(::std::function<void(::MPK::lines)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::MPK::lines>(std::move(response), std::move(ex), std::move(sent), this, &MPK::StopPrx::_iceI_getLines, context);
    }

    /// \cond INTERNAL
    void _iceI_getLines(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MPK::lines>>&, const ::Ice::Context&);
    /// \endcond

    int getID(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &StopPrx::_iceI_getID, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getIDAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &StopPrx::_iceI_getID, context);
    }

    ::std::function<void()>
    getIDAsync(::std::function<void(int)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &MPK::StopPrx::_iceI_getID, context);
    }

    /// \cond INTERNAL
    void _iceI_getID(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    ::std::string getName(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::string>(true, this, &StopPrx::_iceI_getName, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getNameAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &StopPrx::_iceI_getName, context);
    }

    ::std::function<void()>
    getNameAsync(::std::function<void(::std::string)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &MPK::StopPrx::_iceI_getName, context);
    }

    /// \cond INTERNAL
    void _iceI_getName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::Ice::Context&);
    /// \endcond

    arrivals getArrivals(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::MPK::arrivals>(true, this, &StopPrx::_iceI_getArrivals, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getArrivalsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::MPK::arrivals>>().get_future())
    {
        return _makePromiseOutgoing<::MPK::arrivals, P>(false, this, &StopPrx::_iceI_getArrivals, context);
    }

    ::std::function<void()>
    getArrivalsAsync(::std::function<void(::MPK::arrivals)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::MPK::arrivals>(std::move(response), std::move(ex), std::move(sent), this, &MPK::StopPrx::_iceI_getArrivals, context);
    }

    /// \cond INTERNAL
    void _iceI_getArrivals(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MPK::arrivals>>&, const ::Ice::Context&);
    /// \endcond

    void registerUser(const ::std::shared_ptr<UserPrx>& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StopPrx::_iceI_registerUser, user, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto registerUserAsync(const ::std::shared_ptr<UserPrx>& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StopPrx::_iceI_registerUser, user, context);
    }

    ::std::function<void()>
    registerUserAsync(const ::std::shared_ptr<UserPrx>& user,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPK::StopPrx::_iceI_registerUser, user, context);
    }

    /// \cond INTERNAL
    void _iceI_registerUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<UserPrx>&, const ::Ice::Context&);
    /// \endcond

    void unregisterUser(const ::std::shared_ptr<UserPrx>& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StopPrx::_iceI_unregisterUser, user, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto unregisterUserAsync(const ::std::shared_ptr<UserPrx>& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StopPrx::_iceI_unregisterUser, user, context);
    }

    ::std::function<void()>
    unregisterUserAsync(const ::std::shared_ptr<UserPrx>& user,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPK::StopPrx::_iceI_unregisterUser, user, context);
    }

    /// \cond INTERNAL
    void _iceI_unregisterUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<UserPrx>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    StopPrx() = default;
    friend ::std::shared_ptr<StopPrx> IceInternal::createProxy<StopPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class LinePrx : public virtual ::Ice::Proxy<LinePrx, ::Ice::ObjectPrx>
{
public:

    trams getTrams(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::MPK::trams>(true, this, &LinePrx::_iceI_getTrams, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getTramsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::MPK::trams>>().get_future())
    {
        return _makePromiseOutgoing<::MPK::trams, P>(false, this, &LinePrx::_iceI_getTrams, context);
    }

    ::std::function<void()>
    getTramsAsync(::std::function<void(::MPK::trams)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::MPK::trams>(std::move(response), std::move(ex), std::move(sent), this, &MPK::LinePrx::_iceI_getTrams, context);
    }

    /// \cond INTERNAL
    void _iceI_getTrams(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MPK::trams>>&, const ::Ice::Context&);
    /// \endcond

    stops getStops(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::MPK::stops>(true, this, &LinePrx::_iceI_getStops, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getStopsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::MPK::stops>>().get_future())
    {
        return _makePromiseOutgoing<::MPK::stops, P>(false, this, &LinePrx::_iceI_getStops, context);
    }

    ::std::function<void()>
    getStopsAsync(::std::function<void(::MPK::stops)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::MPK::stops>(std::move(response), std::move(ex), std::move(sent), this, &MPK::LinePrx::_iceI_getStops, context);
    }

    /// \cond INTERNAL
    void _iceI_getStops(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MPK::stops>>&, const ::Ice::Context&);
    /// \endcond

    void addTram(const ::std::shared_ptr<TramPrx>& tram, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &LinePrx::_iceI_addTram, tram, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto addTramAsync(const ::std::shared_ptr<TramPrx>& tram, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &LinePrx::_iceI_addTram, tram, context);
    }

    ::std::function<void()>
    addTramAsync(const ::std::shared_ptr<TramPrx>& tram,
                 ::std::function<void()> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPK::LinePrx::_iceI_addTram, tram, context);
    }

    /// \cond INTERNAL
    void _iceI_addTram(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<TramPrx>&, const ::Ice::Context&);
    /// \endcond

    void removeTram(const ::std::shared_ptr<TramPrx>& tram, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &LinePrx::_iceI_removeTram, tram, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto removeTramAsync(const ::std::shared_ptr<TramPrx>& tram, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &LinePrx::_iceI_removeTram, tram, context);
    }

    ::std::function<void()>
    removeTramAsync(const ::std::shared_ptr<TramPrx>& tram,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPK::LinePrx::_iceI_removeTram, tram, context);
    }

    /// \cond INTERNAL
    void _iceI_removeTram(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<TramPrx>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    LinePrx() = default;
    friend ::std::shared_ptr<LinePrx> IceInternal::createProxy<LinePrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class TramPrx : public virtual ::Ice::Proxy<TramPrx, ::Ice::ObjectPrx>
{
public:

    ::std::shared_ptr<StopPrx> getStop(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::shared_ptr<::MPK::StopPrx>>(true, this, &TramPrx::_iceI_getStop, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getStopAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::shared_ptr<::MPK::StopPrx>>>().get_future())
    {
        return _makePromiseOutgoing<::std::shared_ptr<::MPK::StopPrx>, P>(false, this, &TramPrx::_iceI_getStop, context);
    }

    ::std::function<void()>
    getStopAsync(::std::function<void(::std::shared_ptr<::MPK::StopPrx>)> response,
                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                 ::std::function<void(bool)> sent = nullptr,
                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::shared_ptr<::MPK::StopPrx>>(std::move(response), std::move(ex), std::move(sent), this, &MPK::TramPrx::_iceI_getStop, context);
    }

    /// \cond INTERNAL
    void _iceI_getStop(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::shared_ptr<::MPK::StopPrx>>>&, const ::Ice::Context&);
    /// \endcond

    TimeOfDay getStopTime(int stopid, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::MPK::TimeOfDay>(true, this, &TramPrx::_iceI_getStopTime, stopid, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getStopTimeAsync(int stopid, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::MPK::TimeOfDay>>().get_future())
    {
        return _makePromiseOutgoing<::MPK::TimeOfDay, P>(false, this, &TramPrx::_iceI_getStopTime, stopid, context);
    }

    ::std::function<void()>
    getStopTimeAsync(int stopid,
                     ::std::function<void(::MPK::TimeOfDay)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::MPK::TimeOfDay>(std::move(response), std::move(ex), std::move(sent), this, &MPK::TramPrx::_iceI_getStopTime, stopid, context);
    }

    /// \cond INTERNAL
    void _iceI_getStopTime(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MPK::TimeOfDay>>&, int, const ::Ice::Context&);
    /// \endcond

    int getID(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &TramPrx::_iceI_getID, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getIDAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &TramPrx::_iceI_getID, context);
    }

    ::std::function<void()>
    getIDAsync(::std::function<void(int)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &MPK::TramPrx::_iceI_getID, context);
    }

    /// \cond INTERNAL
    void _iceI_getID(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    schedule getSchedule(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::MPK::schedule>(true, this, &TramPrx::_iceI_getSchedule, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto getScheduleAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::MPK::schedule>>().get_future())
    {
        return _makePromiseOutgoing<::MPK::schedule, P>(false, this, &TramPrx::_iceI_getSchedule, context);
    }

    ::std::function<void()>
    getScheduleAsync(::std::function<void(::MPK::schedule)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::MPK::schedule>(std::move(response), std::move(ex), std::move(sent), this, &MPK::TramPrx::_iceI_getSchedule, context);
    }

    /// \cond INTERNAL
    void _iceI_getSchedule(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::MPK::schedule>>&, const ::Ice::Context&);
    /// \endcond

    void registerUser(const ::std::shared_ptr<UserPrx>& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TramPrx::_iceI_registerUser, user, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto registerUserAsync(const ::std::shared_ptr<UserPrx>& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TramPrx::_iceI_registerUser, user, context);
    }

    ::std::function<void()>
    registerUserAsync(const ::std::shared_ptr<UserPrx>& user,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPK::TramPrx::_iceI_registerUser, user, context);
    }

    /// \cond INTERNAL
    void _iceI_registerUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<UserPrx>&, const ::Ice::Context&);
    /// \endcond

    void unregisterUser(const ::std::shared_ptr<UserPrx>& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &TramPrx::_iceI_unregisterUser, user, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto unregisterUserAsync(const ::std::shared_ptr<UserPrx>& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &TramPrx::_iceI_unregisterUser, user, context);
    }

    ::std::function<void()>
    unregisterUserAsync(const ::std::shared_ptr<UserPrx>& user,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPK::TramPrx::_iceI_unregisterUser, user, context);
    }

    /// \cond INTERNAL
    void _iceI_unregisterUser(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<UserPrx>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    TramPrx() = default;
    friend ::std::shared_ptr<TramPrx> IceInternal::createProxy<TramPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class UserPrx : public virtual ::Ice::Proxy<UserPrx, ::Ice::ObjectPrx>
{
public:

    void updateStop(const ::std::shared_ptr<TramPrx>& tram, const ::std::shared_ptr<StopPrx>& stop, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &UserPrx::_iceI_updateStop, tram, stop, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto updateStopAsync(const ::std::shared_ptr<TramPrx>& tram, const ::std::shared_ptr<StopPrx>& stop, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &UserPrx::_iceI_updateStop, tram, stop, context);
    }

    ::std::function<void()>
    updateStopAsync(const ::std::shared_ptr<TramPrx>& tram, const ::std::shared_ptr<StopPrx>& stop,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPK::UserPrx::_iceI_updateStop, tram, stop, context);
    }

    /// \cond INTERNAL
    void _iceI_updateStop(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<TramPrx>&, const ::std::shared_ptr<StopPrx>&, const ::Ice::Context&);
    /// \endcond

    void updateSchedule(const ::std::shared_ptr<StopPrx>& stop, const arrivals& arr, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &UserPrx::_iceI_updateSchedule, stop, arr, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto updateScheduleAsync(const ::std::shared_ptr<StopPrx>& stop, const arrivals& arr, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &UserPrx::_iceI_updateSchedule, stop, arr, context);
    }

    ::std::function<void()>
    updateScheduleAsync(const ::std::shared_ptr<StopPrx>& stop, const arrivals& arr,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &MPK::UserPrx::_iceI_updateSchedule, stop, arr, context);
    }

    /// \cond INTERNAL
    void _iceI_updateSchedule(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::shared_ptr<StopPrx>&, const arrivals&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    UserPrx() = default;
    friend ::std::shared_ptr<UserPrx> IceInternal::createProxy<UserPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits<::MPK::TimeOfDay>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamReader<::MPK::TimeOfDay, S>
{
    static void read(S* istr, ::MPK::TimeOfDay& v)
    {
        istr->readAll(v.hour, v.minute);
    }
};

template<>
struct StreamableTraits<::MPK::ArrivalInfoItem>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPK::ArrivalInfoItem, S>
{
    static void read(S* istr, ::MPK::ArrivalInfoItem& v)
    {
        istr->readAll(v.tram, v.time);
    }
};

template<>
struct StreamableTraits<::MPK::ScheduleItem>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::MPK::ScheduleItem, S>
{
    static void read(S* istr, ::MPK::ScheduleItem& v)
    {
        istr->readAll(v.stop, v.time);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace MPK
{

using LinePtr = ::std::shared_ptr<Line>;
using LinePrxPtr = ::std::shared_ptr<LinePrx>;

using TramPtr = ::std::shared_ptr<Tram>;
using TramPrxPtr = ::std::shared_ptr<TramPrx>;

using StopPtr = ::std::shared_ptr<Stop>;
using StopPrxPtr = ::std::shared_ptr<StopPrx>;

using UserPtr = ::std::shared_ptr<User>;
using UserPrxPtr = ::std::shared_ptr<UserPrx>;

using SIPPtr = ::std::shared_ptr<SIP>;
using SIPPrxPtr = ::std::shared_ptr<SIPPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace MPK
{

class Line;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Line>&);
::IceProxy::Ice::Object* upCast(Line*);
/// \endcond

class Tram;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Tram>&);
::IceProxy::Ice::Object* upCast(Tram*);
/// \endcond

class Stop;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< Stop>&);
::IceProxy::Ice::Object* upCast(Stop*);
/// \endcond

class User;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< User>&);
::IceProxy::Ice::Object* upCast(User*);
/// \endcond

class SIP;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< SIP>&);
::IceProxy::Ice::Object* upCast(SIP*);
/// \endcond

}

}

namespace MPK
{

class Line;
/// \cond INTERNAL
::Ice::Object* upCast(Line*);
/// \endcond
typedef ::IceInternal::Handle< Line> LinePtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::MPK::Line> LinePrx;
typedef LinePrx LinePrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(LinePtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Tram;
/// \cond INTERNAL
::Ice::Object* upCast(Tram*);
/// \endcond
typedef ::IceInternal::Handle< Tram> TramPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::MPK::Tram> TramPrx;
typedef TramPrx TramPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(TramPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class Stop;
/// \cond INTERNAL
::Ice::Object* upCast(Stop*);
/// \endcond
typedef ::IceInternal::Handle< Stop> StopPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::MPK::Stop> StopPrx;
typedef StopPrx StopPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(StopPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class User;
/// \cond INTERNAL
::Ice::Object* upCast(User*);
/// \endcond
typedef ::IceInternal::Handle< User> UserPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::MPK::User> UserPrx;
typedef UserPrx UserPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(UserPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class SIP;
/// \cond INTERNAL
::Ice::Object* upCast(SIP*);
/// \endcond
typedef ::IceInternal::Handle< SIP> SIPPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::MPK::SIP> SIPPrx;
typedef SIPPrx SIPPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(SIPPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace MPK
{

typedef ::std::vector<LinePrx> lines;

typedef ::std::vector<StopPrx> stops;

typedef ::std::vector<TramPrx> trams;

class noSuchLine : public ::Ice::UserException
{
public:

    noSuchLine() {}

#ifdef ICE_CPP11_COMPILER
    noSuchLine(const noSuchLine&) = default;
    virtual ~noSuchLine();
#else
    virtual ~noSuchLine() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual noSuchLine* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
static noSuchLine _iceS_noSuchLine_init;
/// \endcond

class noSuchTram : public ::Ice::UserException
{
public:

    noSuchTram() {}

#ifdef ICE_CPP11_COMPILER
    noSuchTram(const noSuchTram&) = default;
    virtual ~noSuchTram();
#else
    virtual ~noSuchTram() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual noSuchTram* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

struct TimeOfDay
{
    ::Ice::Short hour;
    ::Ice::Short minute;

    bool operator==(const TimeOfDay& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(hour != rhs_.hour)
        {
            return false;
        }
        if(minute != rhs_.minute)
        {
            return false;
        }
        return true;
    }

    bool operator<(const TimeOfDay& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(hour < rhs_.hour)
        {
            return true;
        }
        else if(rhs_.hour < hour)
        {
            return false;
        }
        if(minute < rhs_.minute)
        {
            return true;
        }
        else if(rhs_.minute < minute)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const TimeOfDay& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const TimeOfDay& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const TimeOfDay& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const TimeOfDay& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct ArrivalInfoItem
{
    ::MPK::TramPrx tram;
    ::MPK::TimeOfDay time;
};

typedef ::std::vector<ArrivalInfoItem> arrivals;

class noSuchUser : public ::Ice::UserException
{
public:

    noSuchUser() {}

#ifdef ICE_CPP11_COMPILER
    noSuchUser(const noSuchUser&) = default;
    virtual ~noSuchUser();
#else
    virtual ~noSuchUser() throw();
#endif

    /**
     * Obtains the Slice type ID of this exception.
     * @return The fully-scoped type ID.
     */
    virtual ::std::string ice_id() const;
    /**
     * Polymorphically clones this exception.
     * @return A shallow copy of this exception.
     */
    virtual noSuchUser* ice_clone() const;
    /**
     * Throws this exception.
     */
    virtual void ice_throw() const;

protected:

    /// \cond STREAM
    virtual void _writeImpl(::Ice::OutputStream*) const;
    virtual void _readImpl(::Ice::InputStream*);
    /// \endcond
};

struct ScheduleItem
{
    ::MPK::StopPrx stop;
    ::MPK::TimeOfDay time;
};

typedef ::std::vector<ScheduleItem> schedule;

}

namespace MPK
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::SIP::begin_getLines.
 * Create a wrapper instance by calling ::MPK::newCallback_SIP_getLines.
 */
class Callback_SIP_getLines_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SIP_getLines_Base> Callback_SIP_getLinesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::SIP::begin_addLine.
 * Create a wrapper instance by calling ::MPK::newCallback_SIP_addLine.
 */
class Callback_SIP_addLine_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SIP_addLine_Base> Callback_SIP_addLinePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::SIP::begin_removeLine.
 * Create a wrapper instance by calling ::MPK::newCallback_SIP_removeLine.
 */
class Callback_SIP_removeLine_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SIP_removeLine_Base> Callback_SIP_removeLinePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::SIP::begin_getStop.
 * Create a wrapper instance by calling ::MPK::newCallback_SIP_getStop.
 */
class Callback_SIP_getStop_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_SIP_getStop_Base> Callback_SIP_getStopPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::Stop::begin_getLines.
 * Create a wrapper instance by calling ::MPK::newCallback_Stop_getLines.
 */
class Callback_Stop_getLines_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Stop_getLines_Base> Callback_Stop_getLinesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::Stop::begin_getID.
 * Create a wrapper instance by calling ::MPK::newCallback_Stop_getID.
 */
class Callback_Stop_getID_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Stop_getID_Base> Callback_Stop_getIDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::Stop::begin_getName.
 * Create a wrapper instance by calling ::MPK::newCallback_Stop_getName.
 */
class Callback_Stop_getName_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Stop_getName_Base> Callback_Stop_getNamePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::Stop::begin_getArrivals.
 * Create a wrapper instance by calling ::MPK::newCallback_Stop_getArrivals.
 */
class Callback_Stop_getArrivals_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Stop_getArrivals_Base> Callback_Stop_getArrivalsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::Stop::begin_registerUser.
 * Create a wrapper instance by calling ::MPK::newCallback_Stop_registerUser.
 */
class Callback_Stop_registerUser_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Stop_registerUser_Base> Callback_Stop_registerUserPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::Stop::begin_unregisterUser.
 * Create a wrapper instance by calling ::MPK::newCallback_Stop_unregisterUser.
 */
class Callback_Stop_unregisterUser_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Stop_unregisterUser_Base> Callback_Stop_unregisterUserPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::Line::begin_getTrams.
 * Create a wrapper instance by calling ::MPK::newCallback_Line_getTrams.
 */
class Callback_Line_getTrams_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Line_getTrams_Base> Callback_Line_getTramsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::Line::begin_getStops.
 * Create a wrapper instance by calling ::MPK::newCallback_Line_getStops.
 */
class Callback_Line_getStops_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Line_getStops_Base> Callback_Line_getStopsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::Line::begin_addTram.
 * Create a wrapper instance by calling ::MPK::newCallback_Line_addTram.
 */
class Callback_Line_addTram_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Line_addTram_Base> Callback_Line_addTramPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::Line::begin_removeTram.
 * Create a wrapper instance by calling ::MPK::newCallback_Line_removeTram.
 */
class Callback_Line_removeTram_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Line_removeTram_Base> Callback_Line_removeTramPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::Tram::begin_getStop.
 * Create a wrapper instance by calling ::MPK::newCallback_Tram_getStop.
 */
class Callback_Tram_getStop_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Tram_getStop_Base> Callback_Tram_getStopPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::Tram::begin_getStopTime.
 * Create a wrapper instance by calling ::MPK::newCallback_Tram_getStopTime.
 */
class Callback_Tram_getStopTime_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Tram_getStopTime_Base> Callback_Tram_getStopTimePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::Tram::begin_getID.
 * Create a wrapper instance by calling ::MPK::newCallback_Tram_getID.
 */
class Callback_Tram_getID_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Tram_getID_Base> Callback_Tram_getIDPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::Tram::begin_getSchedule.
 * Create a wrapper instance by calling ::MPK::newCallback_Tram_getSchedule.
 */
class Callback_Tram_getSchedule_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Tram_getSchedule_Base> Callback_Tram_getSchedulePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::Tram::begin_registerUser.
 * Create a wrapper instance by calling ::MPK::newCallback_Tram_registerUser.
 */
class Callback_Tram_registerUser_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Tram_registerUser_Base> Callback_Tram_registerUserPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::Tram::begin_unregisterUser.
 * Create a wrapper instance by calling ::MPK::newCallback_Tram_unregisterUser.
 */
class Callback_Tram_unregisterUser_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_Tram_unregisterUser_Base> Callback_Tram_unregisterUserPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::User::begin_updateStop.
 * Create a wrapper instance by calling ::MPK::newCallback_User_updateStop.
 */
class Callback_User_updateStop_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_updateStop_Base> Callback_User_updateStopPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::MPK::User::begin_updateSchedule.
 * Create a wrapper instance by calling ::MPK::newCallback_User_updateSchedule.
 */
class Callback_User_updateSchedule_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_updateSchedule_Base> Callback_User_updateSchedulePtr;

}

namespace IceProxy
{

namespace MPK
{

class SIP : public virtual ::Ice::Proxy<SIP, ::IceProxy::Ice::Object>
{
public:

    ::MPK::lines getLines(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getLines(_iceI_begin_getLines(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getLines(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getLines(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLines(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLines(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLines(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLines(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLines(const ::MPK::Callback_SIP_getLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLines(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLines(const ::Ice::Context& context, const ::MPK::Callback_SIP_getLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLines(context, cb, cookie);
    }

    ::MPK::lines end_getLines(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getLines(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void addLine(const ::MPK::LinePrx& line, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_addLine(_iceI_begin_addLine(line, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_addLine(const ::MPK::LinePrx& line, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_addLine(line, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addLine(const ::MPK::LinePrx& line, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addLine(line, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addLine(const ::MPK::LinePrx& line, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addLine(line, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addLine(const ::MPK::LinePrx& line, const ::MPK::Callback_SIP_addLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addLine(line, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addLine(const ::MPK::LinePrx& line, const ::Ice::Context& context, const ::MPK::Callback_SIP_addLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addLine(line, context, cb, cookie);
    }

    void end_addLine(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_addLine(const ::MPK::LinePrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void removeLine(const ::MPK::LinePrx& line, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_removeLine(_iceI_begin_removeLine(line, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_removeLine(const ::MPK::LinePrx& line, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_removeLine(line, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeLine(const ::MPK::LinePrx& line, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeLine(line, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeLine(const ::MPK::LinePrx& line, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeLine(line, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeLine(const ::MPK::LinePrx& line, const ::MPK::Callback_SIP_removeLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeLine(line, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeLine(const ::MPK::LinePrx& line, const ::Ice::Context& context, const ::MPK::Callback_SIP_removeLinePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeLine(line, context, cb, cookie);
    }

    void end_removeLine(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_removeLine(const ::MPK::LinePrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::MPK::StopPrx getStop(::Ice::Int ID, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getStop(_iceI_begin_getStop(ID, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getStop(::Ice::Int ID, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getStop(ID, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStop(::Ice::Int ID, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStop(ID, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStop(::Ice::Int ID, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStop(ID, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStop(::Ice::Int ID, const ::MPK::Callback_SIP_getStopPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStop(ID, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStop(::Ice::Int ID, const ::Ice::Context& context, const ::MPK::Callback_SIP_getStopPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStop(ID, context, cb, cookie);
    }

    ::MPK::StopPrx end_getStop(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getStop(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Stop : public virtual ::Ice::Proxy<Stop, ::IceProxy::Ice::Object>
{
public:

    ::MPK::lines getLines(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getLines(_iceI_begin_getLines(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getLines(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getLines(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getLines(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLines(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLines(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLines(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLines(const ::MPK::Callback_Stop_getLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLines(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getLines(const ::Ice::Context& context, const ::MPK::Callback_Stop_getLinesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getLines(context, cb, cookie);
    }

    ::MPK::lines end_getLines(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getLines(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int getID(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getID(_iceI_begin_getID(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getID(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getID(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getID(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getID(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getID(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getID(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getID(const ::MPK::Callback_Stop_getIDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getID(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getID(const ::Ice::Context& context, const ::MPK::Callback_Stop_getIDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getID(context, cb, cookie);
    }

    ::Ice::Int end_getID(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getID(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::std::string getName(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getName(_iceI_begin_getName(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getName(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::MPK::Callback_Stop_getNamePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& context, const ::MPK::Callback_Stop_getNamePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getName(context, cb, cookie);
    }

    ::std::string end_getName(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getName(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::MPK::arrivals getArrivals(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getArrivals(_iceI_begin_getArrivals(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getArrivals(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getArrivals(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getArrivals(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getArrivals(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getArrivals(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getArrivals(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getArrivals(const ::MPK::Callback_Stop_getArrivalsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getArrivals(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getArrivals(const ::Ice::Context& context, const ::MPK::Callback_Stop_getArrivalsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getArrivals(context, cb, cookie);
    }

    ::MPK::arrivals end_getArrivals(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getArrivals(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void registerUser(const ::MPK::UserPrx& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_registerUser(_iceI_begin_registerUser(user, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::MPK::UserPrx& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_registerUser(user, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::MPK::UserPrx& user, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerUser(user, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::MPK::UserPrx& user, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerUser(user, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::MPK::UserPrx& user, const ::MPK::Callback_Stop_registerUserPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerUser(user, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::MPK::UserPrx& user, const ::Ice::Context& context, const ::MPK::Callback_Stop_registerUserPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerUser(user, context, cb, cookie);
    }

    void end_registerUser(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_registerUser(const ::MPK::UserPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void unregisterUser(const ::MPK::UserPrx& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_unregisterUser(_iceI_begin_unregisterUser(user, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(const ::MPK::UserPrx& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_unregisterUser(user, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(const ::MPK::UserPrx& user, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterUser(user, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(const ::MPK::UserPrx& user, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterUser(user, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(const ::MPK::UserPrx& user, const ::MPK::Callback_Stop_unregisterUserPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterUser(user, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(const ::MPK::UserPrx& user, const ::Ice::Context& context, const ::MPK::Callback_Stop_unregisterUserPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterUser(user, context, cb, cookie);
    }

    void end_unregisterUser(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_unregisterUser(const ::MPK::UserPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Line : public virtual ::Ice::Proxy<Line, ::IceProxy::Ice::Object>
{
public:

    ::MPK::trams getTrams(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getTrams(_iceI_begin_getTrams(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getTrams(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getTrams(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getTrams(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTrams(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTrams(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTrams(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTrams(const ::MPK::Callback_Line_getTramsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTrams(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getTrams(const ::Ice::Context& context, const ::MPK::Callback_Line_getTramsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getTrams(context, cb, cookie);
    }

    ::MPK::trams end_getTrams(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getTrams(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::MPK::stops getStops(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getStops(_iceI_begin_getStops(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getStops(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getStops(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStops(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStops(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStops(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStops(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStops(const ::MPK::Callback_Line_getStopsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStops(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStops(const ::Ice::Context& context, const ::MPK::Callback_Line_getStopsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStops(context, cb, cookie);
    }

    ::MPK::stops end_getStops(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getStops(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void addTram(const ::MPK::TramPrx& tram, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_addTram(_iceI_begin_addTram(tram, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_addTram(const ::MPK::TramPrx& tram, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_addTram(tram, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_addTram(const ::MPK::TramPrx& tram, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addTram(tram, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addTram(const ::MPK::TramPrx& tram, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addTram(tram, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addTram(const ::MPK::TramPrx& tram, const ::MPK::Callback_Line_addTramPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addTram(tram, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_addTram(const ::MPK::TramPrx& tram, const ::Ice::Context& context, const ::MPK::Callback_Line_addTramPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_addTram(tram, context, cb, cookie);
    }

    void end_addTram(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_addTram(const ::MPK::TramPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void removeTram(const ::MPK::TramPrx& tram, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_removeTram(_iceI_begin_removeTram(tram, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_removeTram(const ::MPK::TramPrx& tram, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_removeTram(tram, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_removeTram(const ::MPK::TramPrx& tram, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeTram(tram, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeTram(const ::MPK::TramPrx& tram, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeTram(tram, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeTram(const ::MPK::TramPrx& tram, const ::MPK::Callback_Line_removeTramPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeTram(tram, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_removeTram(const ::MPK::TramPrx& tram, const ::Ice::Context& context, const ::MPK::Callback_Line_removeTramPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_removeTram(tram, context, cb, cookie);
    }

    void end_removeTram(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_removeTram(const ::MPK::TramPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class Tram : public virtual ::Ice::Proxy<Tram, ::IceProxy::Ice::Object>
{
public:

    ::MPK::StopPrx getStop(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getStop(_iceI_begin_getStop(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getStop(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getStop(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStop(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStop(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStop(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStop(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStop(const ::MPK::Callback_Tram_getStopPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStop(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStop(const ::Ice::Context& context, const ::MPK::Callback_Tram_getStopPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStop(context, cb, cookie);
    }

    ::MPK::StopPrx end_getStop(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getStop(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::MPK::TimeOfDay getStopTime(::Ice::Int stopid, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getStopTime(_iceI_begin_getStopTime(stopid, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getStopTime(::Ice::Int stopid, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getStopTime(stopid, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getStopTime(::Ice::Int stopid, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStopTime(stopid, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStopTime(::Ice::Int stopid, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStopTime(stopid, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStopTime(::Ice::Int stopid, const ::MPK::Callback_Tram_getStopTimePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStopTime(stopid, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getStopTime(::Ice::Int stopid, const ::Ice::Context& context, const ::MPK::Callback_Tram_getStopTimePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getStopTime(stopid, context, cb, cookie);
    }

    ::MPK::TimeOfDay end_getStopTime(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getStopTime(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int getID(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getID(_iceI_begin_getID(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getID(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getID(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getID(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getID(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getID(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getID(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getID(const ::MPK::Callback_Tram_getIDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getID(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getID(const ::Ice::Context& context, const ::MPK::Callback_Tram_getIDPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getID(context, cb, cookie);
    }

    ::Ice::Int end_getID(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getID(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::MPK::schedule getSchedule(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getSchedule(_iceI_begin_getSchedule(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getSchedule(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getSchedule(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getSchedule(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getSchedule(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getSchedule(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getSchedule(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getSchedule(const ::MPK::Callback_Tram_getSchedulePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getSchedule(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getSchedule(const ::Ice::Context& context, const ::MPK::Callback_Tram_getSchedulePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getSchedule(context, cb, cookie);
    }

    ::MPK::schedule end_getSchedule(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_getSchedule(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void registerUser(const ::MPK::UserPrx& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_registerUser(_iceI_begin_registerUser(user, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::MPK::UserPrx& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_registerUser(user, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::MPK::UserPrx& user, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerUser(user, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::MPK::UserPrx& user, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerUser(user, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::MPK::UserPrx& user, const ::MPK::Callback_Tram_registerUserPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerUser(user, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::MPK::UserPrx& user, const ::Ice::Context& context, const ::MPK::Callback_Tram_registerUserPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_registerUser(user, context, cb, cookie);
    }

    void end_registerUser(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_registerUser(const ::MPK::UserPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void unregisterUser(const ::MPK::UserPrx& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_unregisterUser(_iceI_begin_unregisterUser(user, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(const ::MPK::UserPrx& user, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_unregisterUser(user, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(const ::MPK::UserPrx& user, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterUser(user, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(const ::MPK::UserPrx& user, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterUser(user, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(const ::MPK::UserPrx& user, const ::MPK::Callback_Tram_unregisterUserPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterUser(user, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_unregisterUser(const ::MPK::UserPrx& user, const ::Ice::Context& context, const ::MPK::Callback_Tram_unregisterUserPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_unregisterUser(user, context, cb, cookie);
    }

    void end_unregisterUser(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_unregisterUser(const ::MPK::UserPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class User : public virtual ::Ice::Proxy<User, ::IceProxy::Ice::Object>
{
public:

    void updateStop(const ::MPK::TramPrx& tram, const ::MPK::StopPrx& stop, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_updateStop(_iceI_begin_updateStop(tram, stop, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_updateStop(const ::MPK::TramPrx& tram, const ::MPK::StopPrx& stop, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_updateStop(tram, stop, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updateStop(const ::MPK::TramPrx& tram, const ::MPK::StopPrx& stop, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateStop(tram, stop, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateStop(const ::MPK::TramPrx& tram, const ::MPK::StopPrx& stop, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateStop(tram, stop, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateStop(const ::MPK::TramPrx& tram, const ::MPK::StopPrx& stop, const ::MPK::Callback_User_updateStopPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateStop(tram, stop, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateStop(const ::MPK::TramPrx& tram, const ::MPK::StopPrx& stop, const ::Ice::Context& context, const ::MPK::Callback_User_updateStopPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateStop(tram, stop, context, cb, cookie);
    }

    void end_updateStop(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_updateStop(const ::MPK::TramPrx&, const ::MPK::StopPrx&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void updateSchedule(const ::MPK::StopPrx& stop, const ::MPK::arrivals& arr, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_updateSchedule(_iceI_begin_updateSchedule(stop, arr, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_updateSchedule(const ::MPK::StopPrx& stop, const ::MPK::arrivals& arr, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_updateSchedule(stop, arr, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updateSchedule(const ::MPK::StopPrx& stop, const ::MPK::arrivals& arr, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateSchedule(stop, arr, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateSchedule(const ::MPK::StopPrx& stop, const ::MPK::arrivals& arr, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateSchedule(stop, arr, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateSchedule(const ::MPK::StopPrx& stop, const ::MPK::arrivals& arr, const ::MPK::Callback_User_updateSchedulePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateSchedule(stop, arr, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateSchedule(const ::MPK::StopPrx& stop, const ::MPK::arrivals& arr, const ::Ice::Context& context, const ::MPK::Callback_User_updateSchedulePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateSchedule(stop, arr, context, cb, cookie);
    }

    void end_updateSchedule(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_updateSchedule(const ::MPK::StopPrx&, const ::MPK::arrivals&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace MPK
{

class SIP : public virtual ::Ice::Object
{
public:

    typedef SIPPrx ProxyType;
    typedef SIPPtr PointerType;

    virtual ~SIP();

#ifdef ICE_CPP11_COMPILER
    SIP() = default;
    SIP(const SIP&) = default;
    SIP& operator=(const SIP&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual lines getLines(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void addLine(const LinePrx& line, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_addLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void removeLine(const LinePrx& line, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_removeLine(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual StopPrx getStop(::Ice::Int ID, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getStop(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const SIP& lhs, const SIP& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const SIP& lhs, const SIP& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Stop : public virtual ::Ice::Object
{
public:

    typedef StopPrx ProxyType;
    typedef StopPtr PointerType;

    virtual ~Stop();

#ifdef ICE_CPP11_COMPILER
    Stop() = default;
    Stop(const Stop&) = default;
    Stop& operator=(const Stop&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual lines getLines(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getLines(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Int getID(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getID(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string getName(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getName(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual arrivals getArrivals(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getArrivals(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void registerUser(const UserPrx& user, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_registerUser(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unregisterUser(const UserPrx& user, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_unregisterUser(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Stop& lhs, const Stop& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Stop& lhs, const Stop& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Line : public virtual ::Ice::Object
{
public:

    typedef LinePrx ProxyType;
    typedef LinePtr PointerType;

    virtual ~Line();

#ifdef ICE_CPP11_COMPILER
    Line() = default;
    Line(const Line&) = default;
    Line& operator=(const Line&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual trams getTrams(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getTrams(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual stops getStops(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getStops(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void addTram(const TramPrx& tram, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_addTram(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void removeTram(const TramPrx& tram, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_removeTram(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Line& lhs, const Line& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Line& lhs, const Line& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class Tram : public virtual ::Ice::Object
{
public:

    typedef TramPrx ProxyType;
    typedef TramPtr PointerType;

    virtual ~Tram();

#ifdef ICE_CPP11_COMPILER
    Tram() = default;
    Tram(const Tram&) = default;
    Tram& operator=(const Tram&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual StopPrx getStop(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getStop(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual TimeOfDay getStopTime(::Ice::Int stopid, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getStopTime(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Int getID(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getID(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual schedule getSchedule(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getSchedule(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void registerUser(const UserPrx& user, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_registerUser(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void unregisterUser(const UserPrx& user, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_unregisterUser(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const Tram& lhs, const Tram& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const Tram& lhs, const Tram& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class User : public virtual ::Ice::Object
{
public:

    typedef UserPrx ProxyType;
    typedef UserPtr PointerType;

    virtual ~User();

#ifdef ICE_CPP11_COMPILER
    User() = default;
    User(const User&) = default;
    User& operator=(const User&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void updateStop(const TramPrx& tram, const StopPrx& stop, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_updateStop(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void updateSchedule(const StopPrx& stop, const arrivals& arr, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_updateSchedule(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const User& lhs, const User& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const User& lhs, const User& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::MPK::noSuchLine>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::MPK::noSuchTram>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::MPK::TimeOfDay>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = true;
};

template<typename S>
struct StreamWriter< ::MPK::TimeOfDay, S>
{
    static void write(S* ostr, const ::MPK::TimeOfDay& v)
    {
        ostr->write(v.hour);
        ostr->write(v.minute);
    }
};

template<typename S>
struct StreamReader< ::MPK::TimeOfDay, S>
{
    static void read(S* istr, ::MPK::TimeOfDay& v)
    {
        istr->read(v.hour);
        istr->read(v.minute);
    }
};

template<>
struct StreamableTraits< ::MPK::ArrivalInfoItem>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPK::ArrivalInfoItem, S>
{
    static void write(S* ostr, const ::MPK::ArrivalInfoItem& v)
    {
        ostr->write(v.tram);
        ostr->write(v.time);
    }
};

template<typename S>
struct StreamReader< ::MPK::ArrivalInfoItem, S>
{
    static void read(S* istr, ::MPK::ArrivalInfoItem& v)
    {
        istr->read(v.tram);
        istr->read(v.time);
    }
};

template<>
struct StreamableTraits< ::MPK::noSuchUser>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::MPK::ScheduleItem>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::MPK::ScheduleItem, S>
{
    static void write(S* ostr, const ::MPK::ScheduleItem& v)
    {
        ostr->write(v.stop);
        ostr->write(v.time);
    }
};

template<typename S>
struct StreamReader< ::MPK::ScheduleItem, S>
{
    static void read(S* istr, ::MPK::ScheduleItem& v)
    {
        istr->read(v.stop);
        istr->read(v.time);
    }
};

}
/// \endcond

namespace MPK
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::SIP::begin_getLines.
 * Create a wrapper instance by calling ::MPK::newCallback_SIP_getLines.
 */
template<class T>
class CallbackNC_SIP_getLines : public Callback_SIP_getLines_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const lines&);

    CallbackNC_SIP_getLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SIPPrx proxy = SIPPrx::uncheckedCast(result->getProxy());
        lines ret;
        try
        {
            ret = proxy->end_getLines(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_getLines.
 */
template<class T> Callback_SIP_getLinesPtr
newCallback_SIP_getLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const lines&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SIP_getLines<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_getLines.
 */
template<class T> Callback_SIP_getLinesPtr
newCallback_SIP_getLines(T* instance, void (T::*cb)(const lines&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SIP_getLines<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::SIP::begin_getLines.
 * Create a wrapper instance by calling ::MPK::newCallback_SIP_getLines.
 */
template<class T, typename CT>
class Callback_SIP_getLines : public Callback_SIP_getLines_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const lines&, const CT&);

    Callback_SIP_getLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SIPPrx proxy = SIPPrx::uncheckedCast(result->getProxy());
        lines ret;
        try
        {
            ret = proxy->end_getLines(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_getLines.
 */
template<class T, typename CT> Callback_SIP_getLinesPtr
newCallback_SIP_getLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const lines&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SIP_getLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_getLines.
 */
template<class T, typename CT> Callback_SIP_getLinesPtr
newCallback_SIP_getLines(T* instance, void (T::*cb)(const lines&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SIP_getLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::SIP::begin_addLine.
 * Create a wrapper instance by calling ::MPK::newCallback_SIP_addLine.
 */
template<class T>
class CallbackNC_SIP_addLine : public Callback_SIP_addLine_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_SIP_addLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_addLine.
 */
template<class T> Callback_SIP_addLinePtr
newCallback_SIP_addLine(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SIP_addLine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_addLine.
 */
template<class T> Callback_SIP_addLinePtr
newCallback_SIP_addLine(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SIP_addLine<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_addLine.
 */
template<class T> Callback_SIP_addLinePtr
newCallback_SIP_addLine(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SIP_addLine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_addLine.
 */
template<class T> Callback_SIP_addLinePtr
newCallback_SIP_addLine(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SIP_addLine<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::SIP::begin_addLine.
 * Create a wrapper instance by calling ::MPK::newCallback_SIP_addLine.
 */
template<class T, typename CT>
class Callback_SIP_addLine : public Callback_SIP_addLine_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_SIP_addLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_addLine.
 */
template<class T, typename CT> Callback_SIP_addLinePtr
newCallback_SIP_addLine(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SIP_addLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_addLine.
 */
template<class T, typename CT> Callback_SIP_addLinePtr
newCallback_SIP_addLine(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SIP_addLine<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_addLine.
 */
template<class T, typename CT> Callback_SIP_addLinePtr
newCallback_SIP_addLine(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SIP_addLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_addLine.
 */
template<class T, typename CT> Callback_SIP_addLinePtr
newCallback_SIP_addLine(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SIP_addLine<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::SIP::begin_removeLine.
 * Create a wrapper instance by calling ::MPK::newCallback_SIP_removeLine.
 */
template<class T>
class CallbackNC_SIP_removeLine : public Callback_SIP_removeLine_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_SIP_removeLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SIPPrx proxy = SIPPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_removeLine(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_removeLine.
 */
template<class T> Callback_SIP_removeLinePtr
newCallback_SIP_removeLine(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SIP_removeLine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_removeLine.
 */
template<class T> Callback_SIP_removeLinePtr
newCallback_SIP_removeLine(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SIP_removeLine<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_removeLine.
 */
template<class T> Callback_SIP_removeLinePtr
newCallback_SIP_removeLine(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SIP_removeLine<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_removeLine.
 */
template<class T> Callback_SIP_removeLinePtr
newCallback_SIP_removeLine(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SIP_removeLine<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::SIP::begin_removeLine.
 * Create a wrapper instance by calling ::MPK::newCallback_SIP_removeLine.
 */
template<class T, typename CT>
class Callback_SIP_removeLine : public Callback_SIP_removeLine_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_SIP_removeLine(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SIPPrx proxy = SIPPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_removeLine(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_removeLine.
 */
template<class T, typename CT> Callback_SIP_removeLinePtr
newCallback_SIP_removeLine(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SIP_removeLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_removeLine.
 */
template<class T, typename CT> Callback_SIP_removeLinePtr
newCallback_SIP_removeLine(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SIP_removeLine<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_removeLine.
 */
template<class T, typename CT> Callback_SIP_removeLinePtr
newCallback_SIP_removeLine(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SIP_removeLine<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_removeLine.
 */
template<class T, typename CT> Callback_SIP_removeLinePtr
newCallback_SIP_removeLine(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SIP_removeLine<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::SIP::begin_getStop.
 * Create a wrapper instance by calling ::MPK::newCallback_SIP_getStop.
 */
template<class T>
class CallbackNC_SIP_getStop : public Callback_SIP_getStop_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StopPrx&);

    CallbackNC_SIP_getStop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SIPPrx proxy = SIPPrx::uncheckedCast(result->getProxy());
        StopPrx ret;
        try
        {
            ret = proxy->end_getStop(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_getStop.
 */
template<class T> Callback_SIP_getStopPtr
newCallback_SIP_getStop(const IceUtil::Handle<T>& instance, void (T::*cb)(const StopPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SIP_getStop<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_getStop.
 */
template<class T> Callback_SIP_getStopPtr
newCallback_SIP_getStop(T* instance, void (T::*cb)(const StopPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_SIP_getStop<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::SIP::begin_getStop.
 * Create a wrapper instance by calling ::MPK::newCallback_SIP_getStop.
 */
template<class T, typename CT>
class Callback_SIP_getStop : public Callback_SIP_getStop_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StopPrx&, const CT&);

    Callback_SIP_getStop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        SIPPrx proxy = SIPPrx::uncheckedCast(result->getProxy());
        StopPrx ret;
        try
        {
            ret = proxy->end_getStop(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_getStop.
 */
template<class T, typename CT> Callback_SIP_getStopPtr
newCallback_SIP_getStop(const IceUtil::Handle<T>& instance, void (T::*cb)(const StopPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SIP_getStop<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::SIP::begin_getStop.
 */
template<class T, typename CT> Callback_SIP_getStopPtr
newCallback_SIP_getStop(T* instance, void (T::*cb)(const StopPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_SIP_getStop<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::Stop::begin_getLines.
 * Create a wrapper instance by calling ::MPK::newCallback_Stop_getLines.
 */
template<class T>
class CallbackNC_Stop_getLines : public Callback_Stop_getLines_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const lines&);

    CallbackNC_Stop_getLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StopPrx proxy = StopPrx::uncheckedCast(result->getProxy());
        lines ret;
        try
        {
            ret = proxy->end_getLines(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_getLines.
 */
template<class T> Callback_Stop_getLinesPtr
newCallback_Stop_getLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const lines&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Stop_getLines<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_getLines.
 */
template<class T> Callback_Stop_getLinesPtr
newCallback_Stop_getLines(T* instance, void (T::*cb)(const lines&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Stop_getLines<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::Stop::begin_getLines.
 * Create a wrapper instance by calling ::MPK::newCallback_Stop_getLines.
 */
template<class T, typename CT>
class Callback_Stop_getLines : public Callback_Stop_getLines_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const lines&, const CT&);

    Callback_Stop_getLines(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StopPrx proxy = StopPrx::uncheckedCast(result->getProxy());
        lines ret;
        try
        {
            ret = proxy->end_getLines(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_getLines.
 */
template<class T, typename CT> Callback_Stop_getLinesPtr
newCallback_Stop_getLines(const IceUtil::Handle<T>& instance, void (T::*cb)(const lines&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Stop_getLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_getLines.
 */
template<class T, typename CT> Callback_Stop_getLinesPtr
newCallback_Stop_getLines(T* instance, void (T::*cb)(const lines&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Stop_getLines<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::Stop::begin_getID.
 * Create a wrapper instance by calling ::MPK::newCallback_Stop_getID.
 */
template<class T>
class CallbackNC_Stop_getID : public Callback_Stop_getID_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_Stop_getID(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StopPrx proxy = StopPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getID(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_getID.
 */
template<class T> Callback_Stop_getIDPtr
newCallback_Stop_getID(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Stop_getID<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_getID.
 */
template<class T> Callback_Stop_getIDPtr
newCallback_Stop_getID(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Stop_getID<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::Stop::begin_getID.
 * Create a wrapper instance by calling ::MPK::newCallback_Stop_getID.
 */
template<class T, typename CT>
class Callback_Stop_getID : public Callback_Stop_getID_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_Stop_getID(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StopPrx proxy = StopPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getID(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_getID.
 */
template<class T, typename CT> Callback_Stop_getIDPtr
newCallback_Stop_getID(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Stop_getID<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_getID.
 */
template<class T, typename CT> Callback_Stop_getIDPtr
newCallback_Stop_getID(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Stop_getID<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::Stop::begin_getName.
 * Create a wrapper instance by calling ::MPK::newCallback_Stop_getName.
 */
template<class T>
class CallbackNC_Stop_getName : public Callback_Stop_getName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_Stop_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StopPrx proxy = StopPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_getName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_getName.
 */
template<class T> Callback_Stop_getNamePtr
newCallback_Stop_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Stop_getName<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_getName.
 */
template<class T> Callback_Stop_getNamePtr
newCallback_Stop_getName(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Stop_getName<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::Stop::begin_getName.
 * Create a wrapper instance by calling ::MPK::newCallback_Stop_getName.
 */
template<class T, typename CT>
class Callback_Stop_getName : public Callback_Stop_getName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_Stop_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StopPrx proxy = StopPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_getName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_getName.
 */
template<class T, typename CT> Callback_Stop_getNamePtr
newCallback_Stop_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Stop_getName<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_getName.
 */
template<class T, typename CT> Callback_Stop_getNamePtr
newCallback_Stop_getName(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Stop_getName<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::Stop::begin_getArrivals.
 * Create a wrapper instance by calling ::MPK::newCallback_Stop_getArrivals.
 */
template<class T>
class CallbackNC_Stop_getArrivals : public Callback_Stop_getArrivals_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const arrivals&);

    CallbackNC_Stop_getArrivals(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StopPrx proxy = StopPrx::uncheckedCast(result->getProxy());
        arrivals ret;
        try
        {
            ret = proxy->end_getArrivals(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_getArrivals.
 */
template<class T> Callback_Stop_getArrivalsPtr
newCallback_Stop_getArrivals(const IceUtil::Handle<T>& instance, void (T::*cb)(const arrivals&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Stop_getArrivals<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_getArrivals.
 */
template<class T> Callback_Stop_getArrivalsPtr
newCallback_Stop_getArrivals(T* instance, void (T::*cb)(const arrivals&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Stop_getArrivals<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::Stop::begin_getArrivals.
 * Create a wrapper instance by calling ::MPK::newCallback_Stop_getArrivals.
 */
template<class T, typename CT>
class Callback_Stop_getArrivals : public Callback_Stop_getArrivals_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const arrivals&, const CT&);

    Callback_Stop_getArrivals(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StopPrx proxy = StopPrx::uncheckedCast(result->getProxy());
        arrivals ret;
        try
        {
            ret = proxy->end_getArrivals(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_getArrivals.
 */
template<class T, typename CT> Callback_Stop_getArrivalsPtr
newCallback_Stop_getArrivals(const IceUtil::Handle<T>& instance, void (T::*cb)(const arrivals&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Stop_getArrivals<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_getArrivals.
 */
template<class T, typename CT> Callback_Stop_getArrivalsPtr
newCallback_Stop_getArrivals(T* instance, void (T::*cb)(const arrivals&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Stop_getArrivals<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::Stop::begin_registerUser.
 * Create a wrapper instance by calling ::MPK::newCallback_Stop_registerUser.
 */
template<class T>
class CallbackNC_Stop_registerUser : public Callback_Stop_registerUser_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Stop_registerUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_registerUser.
 */
template<class T> Callback_Stop_registerUserPtr
newCallback_Stop_registerUser(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Stop_registerUser<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_registerUser.
 */
template<class T> Callback_Stop_registerUserPtr
newCallback_Stop_registerUser(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Stop_registerUser<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_registerUser.
 */
template<class T> Callback_Stop_registerUserPtr
newCallback_Stop_registerUser(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Stop_registerUser<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_registerUser.
 */
template<class T> Callback_Stop_registerUserPtr
newCallback_Stop_registerUser(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Stop_registerUser<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::Stop::begin_registerUser.
 * Create a wrapper instance by calling ::MPK::newCallback_Stop_registerUser.
 */
template<class T, typename CT>
class Callback_Stop_registerUser : public Callback_Stop_registerUser_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Stop_registerUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_registerUser.
 */
template<class T, typename CT> Callback_Stop_registerUserPtr
newCallback_Stop_registerUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Stop_registerUser<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_registerUser.
 */
template<class T, typename CT> Callback_Stop_registerUserPtr
newCallback_Stop_registerUser(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Stop_registerUser<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_registerUser.
 */
template<class T, typename CT> Callback_Stop_registerUserPtr
newCallback_Stop_registerUser(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Stop_registerUser<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_registerUser.
 */
template<class T, typename CT> Callback_Stop_registerUserPtr
newCallback_Stop_registerUser(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Stop_registerUser<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::Stop::begin_unregisterUser.
 * Create a wrapper instance by calling ::MPK::newCallback_Stop_unregisterUser.
 */
template<class T>
class CallbackNC_Stop_unregisterUser : public Callback_Stop_unregisterUser_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Stop_unregisterUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StopPrx proxy = StopPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unregisterUser(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_unregisterUser.
 */
template<class T> Callback_Stop_unregisterUserPtr
newCallback_Stop_unregisterUser(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Stop_unregisterUser<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_unregisterUser.
 */
template<class T> Callback_Stop_unregisterUserPtr
newCallback_Stop_unregisterUser(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Stop_unregisterUser<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_unregisterUser.
 */
template<class T> Callback_Stop_unregisterUserPtr
newCallback_Stop_unregisterUser(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Stop_unregisterUser<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_unregisterUser.
 */
template<class T> Callback_Stop_unregisterUserPtr
newCallback_Stop_unregisterUser(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Stop_unregisterUser<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::Stop::begin_unregisterUser.
 * Create a wrapper instance by calling ::MPK::newCallback_Stop_unregisterUser.
 */
template<class T, typename CT>
class Callback_Stop_unregisterUser : public Callback_Stop_unregisterUser_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Stop_unregisterUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StopPrx proxy = StopPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unregisterUser(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_unregisterUser.
 */
template<class T, typename CT> Callback_Stop_unregisterUserPtr
newCallback_Stop_unregisterUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Stop_unregisterUser<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_unregisterUser.
 */
template<class T, typename CT> Callback_Stop_unregisterUserPtr
newCallback_Stop_unregisterUser(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Stop_unregisterUser<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_unregisterUser.
 */
template<class T, typename CT> Callback_Stop_unregisterUserPtr
newCallback_Stop_unregisterUser(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Stop_unregisterUser<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Stop::begin_unregisterUser.
 */
template<class T, typename CT> Callback_Stop_unregisterUserPtr
newCallback_Stop_unregisterUser(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Stop_unregisterUser<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::Line::begin_getTrams.
 * Create a wrapper instance by calling ::MPK::newCallback_Line_getTrams.
 */
template<class T>
class CallbackNC_Line_getTrams : public Callback_Line_getTrams_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const trams&);

    CallbackNC_Line_getTrams(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LinePrx proxy = LinePrx::uncheckedCast(result->getProxy());
        trams ret;
        try
        {
            ret = proxy->end_getTrams(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_getTrams.
 */
template<class T> Callback_Line_getTramsPtr
newCallback_Line_getTrams(const IceUtil::Handle<T>& instance, void (T::*cb)(const trams&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_getTrams<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_getTrams.
 */
template<class T> Callback_Line_getTramsPtr
newCallback_Line_getTrams(T* instance, void (T::*cb)(const trams&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_getTrams<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::Line::begin_getTrams.
 * Create a wrapper instance by calling ::MPK::newCallback_Line_getTrams.
 */
template<class T, typename CT>
class Callback_Line_getTrams : public Callback_Line_getTrams_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const trams&, const CT&);

    Callback_Line_getTrams(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LinePrx proxy = LinePrx::uncheckedCast(result->getProxy());
        trams ret;
        try
        {
            ret = proxy->end_getTrams(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_getTrams.
 */
template<class T, typename CT> Callback_Line_getTramsPtr
newCallback_Line_getTrams(const IceUtil::Handle<T>& instance, void (T::*cb)(const trams&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_getTrams<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_getTrams.
 */
template<class T, typename CT> Callback_Line_getTramsPtr
newCallback_Line_getTrams(T* instance, void (T::*cb)(const trams&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_getTrams<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::Line::begin_getStops.
 * Create a wrapper instance by calling ::MPK::newCallback_Line_getStops.
 */
template<class T>
class CallbackNC_Line_getStops : public Callback_Line_getStops_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const stops&);

    CallbackNC_Line_getStops(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LinePrx proxy = LinePrx::uncheckedCast(result->getProxy());
        stops ret;
        try
        {
            ret = proxy->end_getStops(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_getStops.
 */
template<class T> Callback_Line_getStopsPtr
newCallback_Line_getStops(const IceUtil::Handle<T>& instance, void (T::*cb)(const stops&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_getStops<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_getStops.
 */
template<class T> Callback_Line_getStopsPtr
newCallback_Line_getStops(T* instance, void (T::*cb)(const stops&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_getStops<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::Line::begin_getStops.
 * Create a wrapper instance by calling ::MPK::newCallback_Line_getStops.
 */
template<class T, typename CT>
class Callback_Line_getStops : public Callback_Line_getStops_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const stops&, const CT&);

    Callback_Line_getStops(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LinePrx proxy = LinePrx::uncheckedCast(result->getProxy());
        stops ret;
        try
        {
            ret = proxy->end_getStops(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_getStops.
 */
template<class T, typename CT> Callback_Line_getStopsPtr
newCallback_Line_getStops(const IceUtil::Handle<T>& instance, void (T::*cb)(const stops&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_getStops<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_getStops.
 */
template<class T, typename CT> Callback_Line_getStopsPtr
newCallback_Line_getStops(T* instance, void (T::*cb)(const stops&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_getStops<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::Line::begin_addTram.
 * Create a wrapper instance by calling ::MPK::newCallback_Line_addTram.
 */
template<class T>
class CallbackNC_Line_addTram : public Callback_Line_addTram_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Line_addTram(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_addTram.
 */
template<class T> Callback_Line_addTramPtr
newCallback_Line_addTram(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_addTram<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_addTram.
 */
template<class T> Callback_Line_addTramPtr
newCallback_Line_addTram(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_addTram<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_addTram.
 */
template<class T> Callback_Line_addTramPtr
newCallback_Line_addTram(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_addTram<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_addTram.
 */
template<class T> Callback_Line_addTramPtr
newCallback_Line_addTram(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_addTram<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::Line::begin_addTram.
 * Create a wrapper instance by calling ::MPK::newCallback_Line_addTram.
 */
template<class T, typename CT>
class Callback_Line_addTram : public Callback_Line_addTram_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Line_addTram(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_addTram.
 */
template<class T, typename CT> Callback_Line_addTramPtr
newCallback_Line_addTram(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_addTram<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_addTram.
 */
template<class T, typename CT> Callback_Line_addTramPtr
newCallback_Line_addTram(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_addTram<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_addTram.
 */
template<class T, typename CT> Callback_Line_addTramPtr
newCallback_Line_addTram(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_addTram<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_addTram.
 */
template<class T, typename CT> Callback_Line_addTramPtr
newCallback_Line_addTram(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_addTram<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::Line::begin_removeTram.
 * Create a wrapper instance by calling ::MPK::newCallback_Line_removeTram.
 */
template<class T>
class CallbackNC_Line_removeTram : public Callback_Line_removeTram_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Line_removeTram(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LinePrx proxy = LinePrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_removeTram(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_removeTram.
 */
template<class T> Callback_Line_removeTramPtr
newCallback_Line_removeTram(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_removeTram<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_removeTram.
 */
template<class T> Callback_Line_removeTramPtr
newCallback_Line_removeTram(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_removeTram<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_removeTram.
 */
template<class T> Callback_Line_removeTramPtr
newCallback_Line_removeTram(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_removeTram<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_removeTram.
 */
template<class T> Callback_Line_removeTramPtr
newCallback_Line_removeTram(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Line_removeTram<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::Line::begin_removeTram.
 * Create a wrapper instance by calling ::MPK::newCallback_Line_removeTram.
 */
template<class T, typename CT>
class Callback_Line_removeTram : public Callback_Line_removeTram_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Line_removeTram(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        LinePrx proxy = LinePrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_removeTram(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_removeTram.
 */
template<class T, typename CT> Callback_Line_removeTramPtr
newCallback_Line_removeTram(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_removeTram<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_removeTram.
 */
template<class T, typename CT> Callback_Line_removeTramPtr
newCallback_Line_removeTram(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_removeTram<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_removeTram.
 */
template<class T, typename CT> Callback_Line_removeTramPtr
newCallback_Line_removeTram(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_removeTram<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Line::begin_removeTram.
 */
template<class T, typename CT> Callback_Line_removeTramPtr
newCallback_Line_removeTram(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Line_removeTram<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::Tram::begin_getStop.
 * Create a wrapper instance by calling ::MPK::newCallback_Tram_getStop.
 */
template<class T>
class CallbackNC_Tram_getStop : public Callback_Tram_getStop_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const StopPrx&);

    CallbackNC_Tram_getStop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramPrx proxy = TramPrx::uncheckedCast(result->getProxy());
        StopPrx ret;
        try
        {
            ret = proxy->end_getStop(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_getStop.
 */
template<class T> Callback_Tram_getStopPtr
newCallback_Tram_getStop(const IceUtil::Handle<T>& instance, void (T::*cb)(const StopPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_getStop<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_getStop.
 */
template<class T> Callback_Tram_getStopPtr
newCallback_Tram_getStop(T* instance, void (T::*cb)(const StopPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_getStop<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::Tram::begin_getStop.
 * Create a wrapper instance by calling ::MPK::newCallback_Tram_getStop.
 */
template<class T, typename CT>
class Callback_Tram_getStop : public Callback_Tram_getStop_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const StopPrx&, const CT&);

    Callback_Tram_getStop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramPrx proxy = TramPrx::uncheckedCast(result->getProxy());
        StopPrx ret;
        try
        {
            ret = proxy->end_getStop(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_getStop.
 */
template<class T, typename CT> Callback_Tram_getStopPtr
newCallback_Tram_getStop(const IceUtil::Handle<T>& instance, void (T::*cb)(const StopPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_getStop<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_getStop.
 */
template<class T, typename CT> Callback_Tram_getStopPtr
newCallback_Tram_getStop(T* instance, void (T::*cb)(const StopPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_getStop<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::Tram::begin_getStopTime.
 * Create a wrapper instance by calling ::MPK::newCallback_Tram_getStopTime.
 */
template<class T>
class CallbackNC_Tram_getStopTime : public Callback_Tram_getStopTime_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const TimeOfDay&);

    CallbackNC_Tram_getStopTime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramPrx proxy = TramPrx::uncheckedCast(result->getProxy());
        TimeOfDay ret;
        try
        {
            ret = proxy->end_getStopTime(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_getStopTime.
 */
template<class T> Callback_Tram_getStopTimePtr
newCallback_Tram_getStopTime(const IceUtil::Handle<T>& instance, void (T::*cb)(const TimeOfDay&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_getStopTime<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_getStopTime.
 */
template<class T> Callback_Tram_getStopTimePtr
newCallback_Tram_getStopTime(T* instance, void (T::*cb)(const TimeOfDay&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_getStopTime<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::Tram::begin_getStopTime.
 * Create a wrapper instance by calling ::MPK::newCallback_Tram_getStopTime.
 */
template<class T, typename CT>
class Callback_Tram_getStopTime : public Callback_Tram_getStopTime_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const TimeOfDay&, const CT&);

    Callback_Tram_getStopTime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramPrx proxy = TramPrx::uncheckedCast(result->getProxy());
        TimeOfDay ret;
        try
        {
            ret = proxy->end_getStopTime(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_getStopTime.
 */
template<class T, typename CT> Callback_Tram_getStopTimePtr
newCallback_Tram_getStopTime(const IceUtil::Handle<T>& instance, void (T::*cb)(const TimeOfDay&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_getStopTime<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_getStopTime.
 */
template<class T, typename CT> Callback_Tram_getStopTimePtr
newCallback_Tram_getStopTime(T* instance, void (T::*cb)(const TimeOfDay&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_getStopTime<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::Tram::begin_getID.
 * Create a wrapper instance by calling ::MPK::newCallback_Tram_getID.
 */
template<class T>
class CallbackNC_Tram_getID : public Callback_Tram_getID_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_Tram_getID(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramPrx proxy = TramPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getID(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_getID.
 */
template<class T> Callback_Tram_getIDPtr
newCallback_Tram_getID(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_getID<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_getID.
 */
template<class T> Callback_Tram_getIDPtr
newCallback_Tram_getID(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_getID<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::Tram::begin_getID.
 * Create a wrapper instance by calling ::MPK::newCallback_Tram_getID.
 */
template<class T, typename CT>
class Callback_Tram_getID : public Callback_Tram_getID_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_Tram_getID(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramPrx proxy = TramPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_getID(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_getID.
 */
template<class T, typename CT> Callback_Tram_getIDPtr
newCallback_Tram_getID(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_getID<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_getID.
 */
template<class T, typename CT> Callback_Tram_getIDPtr
newCallback_Tram_getID(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_getID<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::Tram::begin_getSchedule.
 * Create a wrapper instance by calling ::MPK::newCallback_Tram_getSchedule.
 */
template<class T>
class CallbackNC_Tram_getSchedule : public Callback_Tram_getSchedule_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const schedule&);

    CallbackNC_Tram_getSchedule(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramPrx proxy = TramPrx::uncheckedCast(result->getProxy());
        schedule ret;
        try
        {
            ret = proxy->end_getSchedule(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_getSchedule.
 */
template<class T> Callback_Tram_getSchedulePtr
newCallback_Tram_getSchedule(const IceUtil::Handle<T>& instance, void (T::*cb)(const schedule&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_getSchedule<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_getSchedule.
 */
template<class T> Callback_Tram_getSchedulePtr
newCallback_Tram_getSchedule(T* instance, void (T::*cb)(const schedule&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_getSchedule<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::Tram::begin_getSchedule.
 * Create a wrapper instance by calling ::MPK::newCallback_Tram_getSchedule.
 */
template<class T, typename CT>
class Callback_Tram_getSchedule : public Callback_Tram_getSchedule_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const schedule&, const CT&);

    Callback_Tram_getSchedule(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramPrx proxy = TramPrx::uncheckedCast(result->getProxy());
        schedule ret;
        try
        {
            ret = proxy->end_getSchedule(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_getSchedule.
 */
template<class T, typename CT> Callback_Tram_getSchedulePtr
newCallback_Tram_getSchedule(const IceUtil::Handle<T>& instance, void (T::*cb)(const schedule&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_getSchedule<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_getSchedule.
 */
template<class T, typename CT> Callback_Tram_getSchedulePtr
newCallback_Tram_getSchedule(T* instance, void (T::*cb)(const schedule&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_getSchedule<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::Tram::begin_registerUser.
 * Create a wrapper instance by calling ::MPK::newCallback_Tram_registerUser.
 */
template<class T>
class CallbackNC_Tram_registerUser : public Callback_Tram_registerUser_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Tram_registerUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_registerUser.
 */
template<class T> Callback_Tram_registerUserPtr
newCallback_Tram_registerUser(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_registerUser<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_registerUser.
 */
template<class T> Callback_Tram_registerUserPtr
newCallback_Tram_registerUser(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_registerUser<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_registerUser.
 */
template<class T> Callback_Tram_registerUserPtr
newCallback_Tram_registerUser(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_registerUser<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_registerUser.
 */
template<class T> Callback_Tram_registerUserPtr
newCallback_Tram_registerUser(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_registerUser<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::Tram::begin_registerUser.
 * Create a wrapper instance by calling ::MPK::newCallback_Tram_registerUser.
 */
template<class T, typename CT>
class Callback_Tram_registerUser : public Callback_Tram_registerUser_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Tram_registerUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_registerUser.
 */
template<class T, typename CT> Callback_Tram_registerUserPtr
newCallback_Tram_registerUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_registerUser<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_registerUser.
 */
template<class T, typename CT> Callback_Tram_registerUserPtr
newCallback_Tram_registerUser(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_registerUser<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_registerUser.
 */
template<class T, typename CT> Callback_Tram_registerUserPtr
newCallback_Tram_registerUser(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_registerUser<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_registerUser.
 */
template<class T, typename CT> Callback_Tram_registerUserPtr
newCallback_Tram_registerUser(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_registerUser<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::Tram::begin_unregisterUser.
 * Create a wrapper instance by calling ::MPK::newCallback_Tram_unregisterUser.
 */
template<class T>
class CallbackNC_Tram_unregisterUser : public Callback_Tram_unregisterUser_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_Tram_unregisterUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramPrx proxy = TramPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unregisterUser(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_unregisterUser.
 */
template<class T> Callback_Tram_unregisterUserPtr
newCallback_Tram_unregisterUser(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_unregisterUser<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_unregisterUser.
 */
template<class T> Callback_Tram_unregisterUserPtr
newCallback_Tram_unregisterUser(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_unregisterUser<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_unregisterUser.
 */
template<class T> Callback_Tram_unregisterUserPtr
newCallback_Tram_unregisterUser(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_unregisterUser<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_unregisterUser.
 */
template<class T> Callback_Tram_unregisterUserPtr
newCallback_Tram_unregisterUser(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_Tram_unregisterUser<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::Tram::begin_unregisterUser.
 * Create a wrapper instance by calling ::MPK::newCallback_Tram_unregisterUser.
 */
template<class T, typename CT>
class Callback_Tram_unregisterUser : public Callback_Tram_unregisterUser_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_Tram_unregisterUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        TramPrx proxy = TramPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_unregisterUser(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_unregisterUser.
 */
template<class T, typename CT> Callback_Tram_unregisterUserPtr
newCallback_Tram_unregisterUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_unregisterUser<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_unregisterUser.
 */
template<class T, typename CT> Callback_Tram_unregisterUserPtr
newCallback_Tram_unregisterUser(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_unregisterUser<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_unregisterUser.
 */
template<class T, typename CT> Callback_Tram_unregisterUserPtr
newCallback_Tram_unregisterUser(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_unregisterUser<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::Tram::begin_unregisterUser.
 */
template<class T, typename CT> Callback_Tram_unregisterUserPtr
newCallback_Tram_unregisterUser(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_Tram_unregisterUser<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::User::begin_updateStop.
 * Create a wrapper instance by calling ::MPK::newCallback_User_updateStop.
 */
template<class T>
class CallbackNC_User_updateStop : public Callback_User_updateStop_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_User_updateStop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::User::begin_updateStop.
 */
template<class T> Callback_User_updateStopPtr
newCallback_User_updateStop(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_updateStop<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::User::begin_updateStop.
 */
template<class T> Callback_User_updateStopPtr
newCallback_User_updateStop(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_updateStop<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::User::begin_updateStop.
 */
template<class T> Callback_User_updateStopPtr
newCallback_User_updateStop(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_updateStop<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::User::begin_updateStop.
 */
template<class T> Callback_User_updateStopPtr
newCallback_User_updateStop(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_updateStop<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::User::begin_updateStop.
 * Create a wrapper instance by calling ::MPK::newCallback_User_updateStop.
 */
template<class T, typename CT>
class Callback_User_updateStop : public Callback_User_updateStop_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_User_updateStop(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::User::begin_updateStop.
 */
template<class T, typename CT> Callback_User_updateStopPtr
newCallback_User_updateStop(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_updateStop<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::User::begin_updateStop.
 */
template<class T, typename CT> Callback_User_updateStopPtr
newCallback_User_updateStop(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_updateStop<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::User::begin_updateStop.
 */
template<class T, typename CT> Callback_User_updateStopPtr
newCallback_User_updateStop(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_updateStop<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::User::begin_updateStop.
 */
template<class T, typename CT> Callback_User_updateStopPtr
newCallback_User_updateStop(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_updateStop<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::MPK::User::begin_updateSchedule.
 * Create a wrapper instance by calling ::MPK::newCallback_User_updateSchedule.
 */
template<class T>
class CallbackNC_User_updateSchedule : public Callback_User_updateSchedule_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_User_updateSchedule(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::User::begin_updateSchedule.
 */
template<class T> Callback_User_updateSchedulePtr
newCallback_User_updateSchedule(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_updateSchedule<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::User::begin_updateSchedule.
 */
template<class T> Callback_User_updateSchedulePtr
newCallback_User_updateSchedule(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_updateSchedule<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::User::begin_updateSchedule.
 */
template<class T> Callback_User_updateSchedulePtr
newCallback_User_updateSchedule(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_updateSchedule<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::User::begin_updateSchedule.
 */
template<class T> Callback_User_updateSchedulePtr
newCallback_User_updateSchedule(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_updateSchedule<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::MPK::User::begin_updateSchedule.
 * Create a wrapper instance by calling ::MPK::newCallback_User_updateSchedule.
 */
template<class T, typename CT>
class Callback_User_updateSchedule : public Callback_User_updateSchedule_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_User_updateSchedule(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::User::begin_updateSchedule.
 */
template<class T, typename CT> Callback_User_updateSchedulePtr
newCallback_User_updateSchedule(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_updateSchedule<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::User::begin_updateSchedule.
 */
template<class T, typename CT> Callback_User_updateSchedulePtr
newCallback_User_updateSchedule(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_updateSchedule<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::User::begin_updateSchedule.
 */
template<class T, typename CT> Callback_User_updateSchedulePtr
newCallback_User_updateSchedule(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_updateSchedule<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::MPK::User::begin_updateSchedule.
 */
template<class T, typename CT> Callback_User_updateSchedulePtr
newCallback_User_updateSchedule(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_updateSchedule<T, CT>(instance, 0, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
